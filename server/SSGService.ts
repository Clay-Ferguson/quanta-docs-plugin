import { Request, Response } from 'express';
import * as fs from 'fs';
import * as path from 'path';
import { config } from '../../../server/Config.js';

export interface GenerateDocOptions {
	includeFileNames: boolean;
	includeSeparatorLines: boolean;
	generateRecursively: boolean;
	generateTableOfContents: boolean;
}

/**
 * Static Site Generation Service
 * 
 * Scans the ordered files/folders (ordered by prefix ordinal) and generates MARKDOWN files that are browsable as a coherent structure with 
 * an optional Table of Contents.
 */
class SSGService {
    /**
     * Generates static site by creating _index.md files in each folder containing
     * concatenated markdown content from ordered files in that folder
     * 
     * @param req - Express request object containing treeFolder and docRootKey in body
     * @param res - Express response object for sending back the result
     */
    generateStaticSite = async (req: Request, res: Response) => {
        try {
            const { treeFolder, docRootKey } = req.body;
            
            console.log(`SSG: Generating static site for folder: ${treeFolder}, docRootKey: ${docRootKey}`);
            
            // Get the absolute root path using the docRootKey
            const rootConfig = config.getPublicFolderByKey(docRootKey);
            if (!rootConfig || !rootConfig.path) {
                res.status(400).json({ 
                    error: `Invalid docRootKey: ${docRootKey}` 
                });
                return;
            }
            
            // Construct the absolute path to the target folder
            let absolutePath: string;
            if (!treeFolder || treeFolder === '/') {
                absolutePath = rootConfig.path;
            } else {
                // Remove leading slash if present for path.join
                const cleanTreeFolder = treeFolder.startsWith('/') ? treeFolder.substring(1) : treeFolder;
                absolutePath = path.join(rootConfig.path, cleanTreeFolder);
            }
            
            // Verify the path exists
            if (!fs.existsSync(absolutePath)) {
                res.status(404).json({ 
                    error: `Path not found: ${absolutePath}` 
                });
                return;
            }
            
            // Call the generateDoc method with default options suitable for SSG
            // todo-2: make user able to set these on the UI
            const options = {
                includeFileNames: false,
                includeSeparatorLines: true,
                generateRecursively: true,
                generateTableOfContents: true
            };
            
            this.generateDoc(absolutePath, options);
            
            res.json({ 
                message: `SSG generation completed for folder: ${treeFolder}`,
                treeFolder: treeFolder,
                docRootKey: docRootKey,
                absolutePath: absolutePath
            });
            
        } catch (error) {
            console.error('SSG Error:', error);
            res.status(500).json({ 
                error: 'Failed to generate static site' 
            });
        }
    };

    /**
     * Generates documentation for a folder by processing all ordered files and subfolders
     * Creates _index.md files with concatenated content based on provided options
     * 
     * @param folderPath - Absolute path to the folder to process
     * @param options - Configuration options for document generation
     * @param isRootCall - Whether this is the initial call (used for table of contents generation)
     * @param tableOfContents - Array to accumulate table of contents entries
     */
    generateDoc = (folderPath: string, options: GenerateDocOptions = 
    { 
        includeFileNames: true, 
        includeSeparatorLines: true, 
        generateRecursively: false, 
        generateTableOfContents: false 
    }, 
    isRootCall: boolean = true, tableOfContents: string[] = []) => {
        fs.readdir(folderPath, (err, files) => {
            if (err) {
                // make this error to back to user.
                console.error('Error reading folder: ' + err.message);
                return;
            }

            const sortedFiles = this.sortFiles(folderPath, files);
            let fullContent = '<!-- DO NOT EDIT! Auto-generated by Quanta -->\n\n';

            // Generate table of contents if this is the root call and option is enabled
            if (isRootCall && options.generateTableOfContents && options.generateRecursively) {
                // First pass: build table of contents recursively
                this.buildTableOfContents(folderPath, options, tableOfContents, 0);
			
                // Add table of contents to the beginning of the document
                if (tableOfContents.length > 0) {
                    fullContent += '### Table of Contents\n\n';
                    fullContent += tableOfContents.join('\n') + '\n\n';
                    fullContent += '----\n';
                }
            }

            sortedFiles.forEach((item: any) => {
                const itemPath = path.join(folderPath, item);
                const stats = fs.statSync(itemPath);
			
                if (stats.isFile()) {
                    const content = fs.readFileSync(itemPath, 'utf8');
				
                    // Add file name if option is enabled
                    if (options.includeFileNames) {
                        fullContent += `📄 ${item}\n\n`;
                    }
				
                    if (/\.(png|jpe?g)$/i.test(item)) {
                        fullContent += `![${this.formatDisplayName(item)}](${item})\n\n`;
                    } else {
                        fullContent += `${content}\n\n`;
                    }
				
                    // Add separator line if option is enabled
                    if (options.includeSeparatorLines) {
                        fullContent += '----\n';
                    }
                } else if (stats.isDirectory()) {
                    // Check if folder ends with '_' (inline folder convention)
                    if (item.endsWith('_')) {                       
                        // Display folder only if it's not already expected to be in the TOC 
                        // if (options.includeFileNames && !(isRootCall && options.generateTableOfContents)) {
                        //     const displayName = this.removeNumberPrefix(item);
                        //     fullContent += `📁 ${displayName}\n\n`;
                        // }
					
                        // Process all content in the inline folder and append to current content
                        fullContent += this.processInlineFolderContent(itemPath, options);
					
                        // Add separator line if option is enabled
                        if (options.includeSeparatorLines) {
                            fullContent += '----\n';
                        }
                    } else {
                        // Regular folder - handle normally
                        // If recursive option is enabled, generate _index.md for subfolder first
                        if (options.generateRecursively) {
                            this.generateDoc(itemPath, options, false, tableOfContents);
                        }
					
                        // Display folder link only if it's not already expected to be in the TOC 
                        // if (!(isRootCall && options.generateTableOfContents)) {
                        // Create a markdown link to the _index.md file in the folder
                        // Use removeNumberPrefix to display clean folder name without number prefix
                        const displayName = this.removeNumberPrefix(item);
                        fullContent += `📁 [${this.formatDisplayName(displayName)}](./${item}/_index.md)\n\n`;
                        // }
					
                        // Add separator line if option is enabled
                        if (options.includeSeparatorLines) {
                            fullContent += '----\n';
                        }
                    }
                }
            });

            const outputFilePath = path.join(folderPath, '_index.md');
            fs.writeFile(outputFilePath, fullContent.trim(), (err) => {
                if (err) {
                    throw new Error(`Failed to write _index.md file: ${err.message}`);
                }
                // DO NOT DELETE: This opens the text view of the file
                // vscode.window.showTextDocument(vscode.Uri.file(outputFilePath));
			
                // Only open the markdown file for the root level (original call)
                if (isRootCall) {
                    // openMarkdownFile(outputFilePath);
                }
            });
        });
    }

    /**
     * Helper function to process inline folder content (folders ending with '_')
     * Inline folders have their content embedded directly rather than linked
     * 
     * @param folderPath - Absolute path to the inline folder to process
     * @param options - Configuration options for document generation
     * @returns String containing the processed markdown content from the inline folder
     */
    processInlineFolderContent = (folderPath: string, options: GenerateDocOptions): string => {
        let inlineContent = '';
	
        try {
            const files = fs.readdirSync(folderPath);
            const sortedFiles = this.sortFiles(folderPath, files);
		
            sortedFiles.forEach((item) => {
                const itemPath = path.join(folderPath, item);
                const stats = fs.statSync(itemPath);
			
                if (stats.isFile()) {
                    const content = fs.readFileSync(itemPath, 'utf8');
				
                    // Add file name if option is enabled
                    if (options.includeFileNames) {
                        inlineContent += `📄 ${item}\n\n`;
                    }
				
                    if (/\.(png|jpe?g)$/i.test(item)) {
                        inlineContent += `![${this.formatDisplayName(item)}](${item})\n\n`;
                    } else {
                        inlineContent += `${content}\n\n`;
                    }
				
                    // Add separator line if option is enabled
                    if (options.includeSeparatorLines) {
                        inlineContent += '----\n';
                    }
                } else if (stats.isDirectory()) {
                    // Check if this subfolder also ends with '_' (nested inline folders)
                    if (item.endsWith('_')) {
                        // Recursively process nested inline folder
                        // if (options.includeFileNames) {
                        //     const displayName = this.removeNumberPrefix(item);
                        //     inlineContent += `📁 ${displayName}\n\n`;
                        // }
                        inlineContent += this.processInlineFolderContent(itemPath, options);
                        if (options.includeSeparatorLines) {
                            inlineContent += '----\n';
                        }
                    } else {
                        // Regular subfolder - generate its own _index.md if recursive is enabled
                        // Note: Pass empty array for tableOfContents to prevent adding to TOC since we're inside an inline folder
                        if (options.generateRecursively) {
                            this.generateDoc(itemPath, options, false, []);
                        }
					
                        // Create a markdown link to the _index.md file in the folder
                        const displayName = this.removeNumberPrefix(item);
                        inlineContent += `📁 [${this.formatDisplayName(displayName)}](./${item}/_index.md)\n\n`;
					
                        if (options.includeSeparatorLines) {
                            inlineContent += '----\n';
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error processing inline folder content:', folderPath, error);
        }
        return inlineContent;
    }

    /**
     * Sorts files based on their numeric prefix (e.g., "01_", "02_", etc.)
     * Only includes files that start with a number followed by an underscore
     * 
     * @param folderPath - Path to the folder (used for context, not directly in sorting)
     * @param files - Array of file names to sort
     * @returns Array of file names sorted by their numeric prefix
     */
    sortFiles = (folderPath: string, files: string[]): string[] => {
        const sortedFiles = files
            .filter((file) => /^\d+_/.test(file))
            .sort((a, b) => {
                return this.getFileNumber(a) - this.getFileNumber(b);
            });
        return sortedFiles;
    }

    /**
     * Extracts the numeric prefix from a file name for sorting purposes
     * 
     * @param fileName - File name with numeric prefix (e.g., "01_example.md")
     * @returns The numeric value of the prefix
     */
    getFileNumber = (fileName: string): number => {
        return parseInt(fileName.split('_')[0], 10);
    }

    /**
     * Recursively builds a table of contents for all folders in the directory structure
     * Skips inline folders (ending with '_') as they don't have separate _index.md files
     * 
     * @param folderPath - Current folder path being processed
     * @param options - Configuration options for document generation
     * @param tableOfContents - Array to accumulate table of contents entries
     * @param depth - Current nesting depth for proper indentation
     * @param rootPath - Root path for calculating relative links (defaults to folderPath)
     */
    buildTableOfContents = (folderPath: string, options: GenerateDocOptions, tableOfContents: string[], depth: number, rootPath: string = folderPath) =>  {
        try {
            const files = fs.readdirSync(folderPath);
            const sortedFiles = this.sortFiles(folderPath, files);
		
            sortedFiles.forEach((item) => {
            
                const itemPath = path.join(folderPath, item);
                const stats = fs.statSync(itemPath);
			
                if (stats.isDirectory()) {
                    // Skip inline folders (folders ending with '_') as they don't have their own _index.md files
                    if (!item.endsWith('_')) {
                        // Create the markdown indentation based on depth
                        const indent = '  '.repeat(depth); // 2 spaces per depth level
					
                        // Use removeNumberPrefix to display clean folder name without number prefix
                        const displayName = this.removeNumberPrefix(item);
					
                        // Create a relative path from the root to this folder's _index.md
                        const relativePath = path.relative(rootPath, path.join(itemPath, '_index.md')).replace(/\\/g, '/');
					
                        // Add the table of contents entry
                        tableOfContents.push(`${indent}- [${this.formatDisplayName(displayName)}](./${relativePath})`);
					
                        // Recursively process subfolders
                        if (options.generateRecursively) {
                            this.buildTableOfContents(itemPath, options, tableOfContents, depth + 1, rootPath);
                        }
                    }
                }
            });
        } catch (error) {
            // Handle any file system errors gracefully
            console.error('Error building table of contents for:', folderPath, error);
        }
    }

    /**
     * Removes the numeric prefix from a file or folder name
     * Useful for displaying clean names without the ordering prefix
     * 
     * @param fileName - File name with numeric prefix (e.g., "01_example.md")
     * @returns File name without the numeric prefix (e.g., "example.md")
     */
    removeNumberPrefix = (fileName: string): string => {
        const underscoreIndex = fileName.indexOf('_');
        if (underscoreIndex !== -1) {
            return fileName.substring(underscoreIndex + 1);
        }
        return fileName;
    }

    /**
     * Formats a display name by converting dashes and underscores to spaces
     * and capitalizing the first letter of each word
     * 
     * @param name - Raw name to format
     * @returns Formatted display name with proper capitalization and spacing
     */
    formatDisplayName = (name: string): string => {
        // Converts all dashes and underscores to spaces
        return name.replace(/[-_]/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
    }
}

export const ssg = new SSGService();